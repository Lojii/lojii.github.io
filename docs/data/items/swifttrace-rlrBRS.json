{
  "id": "swifttrace-rlrBRS",
  "type": "repo",
  "name": "SwiftTrace",
  "nameEn": "SwiftTrace",
  "url": "https://github.com/johnno1962/SwiftTrace",
  "summary": "追踪Swift和Objective-C方法调用",
  "description": "",
  "notes": "",
  "images": [],
  "thumbnail": null,
  "category": "iOS",
  "tags": [
    "测试"
  ],
  "github": {
    "stars": 743,
    "forks": 54,
    "language": "Swift",
    "license": "NOASSERTION",
    "lastUpdate": "2026-01-13",
    "topics": [],
    "createdAt": "2016-06-10"
  },
  "archived": false,
  "createdAt": "2026-01-24",
  "updatedAt": "2026-01-24",
  "originalContent": "<div id=\"readme\" class=\"md\" data-path=\"README.md\"><article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><div class=\"markdown-heading\" dir=\"auto\"><h1 class=\"heading-element\" dir=\"auto\">SwiftTrace</h1><a id=\"user-content-swifttrace\" class=\"anchor\" aria-label=\"Permalink: SwiftTrace\" href=\"#swifttrace\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Trace Swift and Objective-C method invocations of non-final classes in an app bundle or framework.\nThink <a href=\"https://github.com/johnno1962/Xtrace\">Xtrace</a> but for Swift and Objective-C. You can also\nadd \"aspects\" to member functions of non-final Swift classes to have a closure called before or after\na function implementation executes which in turn can modify incoming arguments or the return value!\nApart from the logging functionality, with binary distribution of Swift frameworks on the horizon perhaps\nthis will be of use in the same way \"Swizzling\" was in days of yore.\nTL;DR consult the file <a href=\"https://github.com/johnno1962/InjectionNext/blob/main/Sources/InjectionNext/InjectionNext.swift#L89\">InjectionNext.swift</a> for some examples of the various ways this package can be used to trace methods and functions.</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/johnno1962/SwiftTrace/blob/HEAD/SwiftTrace.gif\"><img src=\"https://raw.githubusercontent.com/johnno1962/SwiftTrace/HEAD/SwiftTrace.gif\" alt=\"SwiftTrace Example\" data-animated-image=\"\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\">Note: none of these features will work on a class or method that is final or internal in\na module compiled with whole module optimisation as the dispatch of the method\nwill be \"direct\" i.e. linked to a symbol at the call site rather than going through the\nclass' vtable. As such it is possible to trace calls to methods of a struct but only\nif they are referenced through a protocol as they use a <code>witness table</code> which\ncan be patched.</p>\n<p dir=\"auto\">SwiftTrace can be used with the Swift Package Manager or as a CocoaPod by\nadding the following to your project's Podfile:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    pod 'SwiftTrace'\"><pre>    pod 'SwiftTrace'</pre></div>\n<p dir=\"auto\">Once the project has rebuilt, import SwiftTrace into the application's AppDelegate and add something like the following to the beginning of\nit's didFinishLaunchingWithOptions method:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    SwiftTrace.traceBundle(containing: type(of: self))\"><pre>    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceBundle</span><span class=\"pl-kos\">(</span>containing<span class=\"pl-kos\">:</span> <span class=\"pl-en\">type</span><span class=\"pl-kos\">(</span>of<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">self</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">This traces all classes defined in the main application bundle.\nTo trace, for example, all classes in the RxSwift Pod add the following</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    SwiftTrace.traceBundle(containing: RxSwift.DisposeBase.self)\"><pre>    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceBundle</span><span class=\"pl-kos\">(</span>containing<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">RxSwift</span><span class=\"pl-kos\">.</span>DisposeBase<span class=\"pl-kos\">.</span>self<span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">This gives output in the Xcode debug console such as that above.</p>\n<p dir=\"auto\">To trace a system framework such as UIKit you can trace classes using a pattern:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    SwiftTrace.traceClasses(matchingPattern:&quot;^UI&quot;)\"><pre>    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceClasses</span><span class=\"pl-kos\">(</span>matchingPattern<span class=\"pl-kos\">:</span><span class=\"pl-s\">\"</span><span class=\"pl-s\">^UI</span><span class=\"pl-s\">\"</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">Individual classes can be traced using the underlying api:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    SwiftTrace.trace(aClass: MyClass.self)\"><pre>    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">trace</span><span class=\"pl-kos\">(</span>aClass<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">MyClass</span><span class=\"pl-kos\">.</span>self<span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">Or to trace all methods of instances of a particular class including those of their superclasses\nuse the following:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    SwiftTrace.traceInstances(ofClass: aClass)\"><pre>    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceInstances</span><span class=\"pl-kos\">(</span>ofClass<span class=\"pl-kos\">:</span> aClass<span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">Or to trace only a particular instance use the following:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    SwiftTrace.trace(anInstance: anObject)\"><pre>    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">trace</span><span class=\"pl-kos\">(</span>anInstance<span class=\"pl-kos\">:</span> anObject<span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">If you have specified <code>\"-Xlinker -interposable\"</code> in your project's <code>\"Other Linker Flags\"</code>\nit's possible to trace all methods in the application's main bundle at once which can be\nuseful for profiling <code>SwiftUI</code> using the following call:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    SwiftTrace.traceMainBundleMethods()\"><pre>    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceMainBundleMethods</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">It is possible to trace methods of a structs or other types if they are messaged through\nprotools as this would then be indirect via what is called a <code>witness table</code>. Tracing\nprotocols is available at the bundle level where the bundle being traced is specified\nusing a class instance. They can be further filtered by an optional regular expression.\nFor example, the following:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"SwiftTrace.traceProtocolsInBundle(containing: AClassInTheBundle.self, matchingPattern: &quot;regexp&quot;)\"><pre><span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceProtocolsInBundle</span><span class=\"pl-kos\">(</span>containing<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">AClassInTheBundle</span><span class=\"pl-kos\">.</span>self<span class=\"pl-kos\">,</span> matchingPattern<span class=\"pl-kos\">:</span> <span class=\"pl-s\">\"</span><span class=\"pl-s\">regexp</span><span class=\"pl-s\">\"</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">For example, to trace internal calls made in the <code>SwiftUI</code> framework you can use the following:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {\n    SwiftTrace.traceProtocolsInBundle(containing: UIHostingController&lt;HomeView&gt;.self)\n    return true\n}\"><pre><span class=\"pl-en\">func</span> application<span class=\"pl-kos\">(</span>_ application<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">UIApplication</span><span class=\"pl-kos\">,</span> didFinishLaunchingWithOptions launchOptions<span class=\"pl-kos\">:</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">UIApplication</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">LaunchOptionsKey</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">Any</span><span class=\"pl-kos\">]</span><span class=\"pl-c1\"><span class=\"pl-c1\">?</span></span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">-&gt;</span> <span class=\"pl-smi\">Bool</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceProtocolsInBundle</span><span class=\"pl-kos\">(</span>containing<span class=\"pl-kos\">:</span> UIHostingController<span class=\"pl-c1\">&lt;</span>HomeView<span class=\"pl-c1\">&gt;</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">self</span><span class=\"pl-kos\">)</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">true</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Which traces are applied can be filtered using method name inclusion and exclusion regexps.</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    SwiftTrace.methodInclusionPattern = &quot;TestClass&quot;\n    SwiftTrace.methodExclusionPattern = &quot;init|&quot;+SwiftTrace.defaultMethodExclusions\"><pre>    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span>methodInclusionPattern <span class=\"pl-c1\">=</span> <span class=\"pl-s\">\"</span><span class=\"pl-s\">TestClass</span><span class=\"pl-s\">\"</span>\n    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span>methodExclusionPattern <span class=\"pl-c1\">=</span> <span class=\"pl-s\">\"</span><span class=\"pl-s\">init|</span><span class=\"pl-s\">\"</span><span class=\"pl-c1\">+</span>SwiftTrace<span class=\"pl-kos\">.</span>defaultMethodExclusions</pre></div>\n<p dir=\"auto\">These methods must be called before you start the trace as they are applied during the \"Swizzle\" phase.\nThere is a default set of exclusions setup as a result of testing by tracing UIKit.</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"open class var defaultMethodExclusions: String {\n    return &quot;&quot;&quot;\n        \\\\.getter| (?:retain|_tryRetain|release|_isDeallocating|.cxx_destruct|dealloc|description| debugDescription)]|initWithCoder|\\\n        ^\\\\+\\\\[(?:Reader_Base64|UI(?:NibStringIDTable|NibDecoder|CollectionViewData|WebTouchEventsGestureRecognizer)) |\\\n        ^.\\\\[(?:UIView|RemoteCapture) |UIDeviceWhiteColor initWithWhite:alpha:|UIButton _defaultBackgroundImageForType:andState:|\\\n        UIImage _initWithCompositedSymbolImageLayers:name:alignUsingBaselines:|\\\n        _UIWindowSceneDeviceOrientationSettingsDiffAction _updateDeviceOrientationWithSettingObserverContext:windowScene:transitionContext:|\\\n        UIColorEffect colorEffectSaturate:|UIWindow _windowWithContextId:|RxSwift.ScheduledDisposable.dispose| ns(?:li|is)_\n        &quot;&quot;&quot;\n}\"><pre class=\"notranslate\"><code>open class var defaultMethodExclusions: String {\n    return \"\"\"\n        \\\\.getter| (?:retain|_tryRetain|release|_isDeallocating|.cxx_destruct|dealloc|description| debugDescription)]|initWithCoder|\\\n        ^\\\\+\\\\[(?:Reader_Base64|UI(?:NibStringIDTable|NibDecoder|CollectionViewData|WebTouchEventsGestureRecognizer)) |\\\n        ^.\\\\[(?:UIView|RemoteCapture) |UIDeviceWhiteColor initWithWhite:alpha:|UIButton _defaultBackgroundImageForType:andState:|\\\n        UIImage _initWithCompositedSymbolImageLayers:name:alignUsingBaselines:|\\\n        _UIWindowSceneDeviceOrientationSettingsDiffAction _updateDeviceOrientationWithSettingObserverContext:windowScene:transitionContext:|\\\n        UIColorEffect colorEffectSaturate:|UIWindow _windowWithContextId:|RxSwift.ScheduledDisposable.dispose| ns(?:li|is)_\n        \"\"\"\n}\n</code></pre></div>\n<p dir=\"auto\">If you want to further process output you can define your own custom tracing sub class:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    class MyTracer: SwiftTrace.Decorated {\n\n        override func onEntry(stack: inout SwiftTrace.EntryStack) {\n            print( &quot;&gt;&gt; &quot;+stack )\n        }\n    }\n    \n    SwiftTrace.swizzleFactory = MyTracer.self\"><pre>    <span class=\"pl-k\">class</span> <span class=\"pl-smi\">MyTracer</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Decorated</span> <span class=\"pl-kos\">{</span>\n\n        <span class=\"pl-k\"><span class=\"pl-k\">override</span></span> <span class=\"pl-en\">func</span> onEntry<span class=\"pl-kos\">(</span>stack<span class=\"pl-kos\">:</span> <span class=\"pl-k\">inout</span> <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">EntryStack</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n            <span class=\"pl-en\">print</span><span class=\"pl-kos\">(</span> <span class=\"pl-s\">\"</span><span class=\"pl-s\">&gt;&gt; </span><span class=\"pl-s\">\"</span><span class=\"pl-c1\">+</span>stack <span class=\"pl-kos\">)</span>\n        <span class=\"pl-kos\">}</span>\n    <span class=\"pl-kos\">}</span>\n    \n    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span>swizzleFactory <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">MyTracer</span><span class=\"pl-kos\">.</span>self</pre></div>\n<p dir=\"auto\">As the amount of of data logged can quickly get out of hand you can control what is\nlogged by combing traces with the optional <code>subLevels</code> parameter to the above functions.\nFor example, the following puts a trace on all of UIKit but will only log calls to methods\nof the target instance and up to three levels of calls those method make:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    SwiftTrace.traceBundle(containing: UIView.self)\n    SwiftTrace.trace(anInstance: anObject, subLevels: 3)\"><pre>    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceBundle</span><span class=\"pl-kos\">(</span>containing<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">UIView</span><span class=\"pl-kos\">.</span>self<span class=\"pl-kos\">)</span>\n    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">trace</span><span class=\"pl-kos\">(</span>anInstance<span class=\"pl-kos\">:</span> anObject<span class=\"pl-kos\">,</span> subLevels<span class=\"pl-kos\">:</span> <span class=\"pl-c1\">3</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">Or, the following will log methods of the application and calls to RxSwift they make:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    SwiftTrace.traceBundle(containing: RxSwift.DisposeBase.self)\n    SwiftTrace.traceMainBundle(subLevels: 3)\"><pre>    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceBundle</span><span class=\"pl-kos\">(</span>containing<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">RxSwift</span><span class=\"pl-kos\">.</span>DisposeBase<span class=\"pl-kos\">.</span>self<span class=\"pl-kos\">)</span>\n    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceMainBundle</span><span class=\"pl-kos\">(</span>subLevels<span class=\"pl-kos\">:</span> <span class=\"pl-c1\">3</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">If this seems arbitrary the rules are reasonably simple. When you add a trace with a\nnon-zero subLevels parameter all previous traces are inhibited unless they are being\nmade up to subLevels inside a method in the most recent trace or if they where filtered\nanyway by a class or instance (traceInstances(ofClass:) and trace(anInstance:)).</p>\n<p dir=\"auto\">If you would like to extend SwiftTrace to be able to log one of your app's types\nthere are two steps. First, you may need to extend the type to conform to\nSwiftTraceFloatArg if it contains only float only float types for example SwiftUI.EdgeInsets.</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"extension SwiftUI.EdgeInsets: SwiftTraceFloatArg {}\"><pre><span class=\"pl-k\">extension</span> <span class=\"pl-smi\">SwiftUI</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">EdgeInsets</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">SwiftTraceFloatArg</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Then, add a handler for the type using the following api:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    SwiftTrace.addFormattedType(SwiftUI.EdgeInsets.self, prefix: &quot;SwiftUI&quot;)\"><pre>    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">addFormattedType</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">SwiftUI</span><span class=\"pl-kos\">.</span>EdgeInsets<span class=\"pl-kos\">.</span>self<span class=\"pl-kos\">,</span> prefix<span class=\"pl-kos\">:</span> <span class=\"pl-s\">\"</span><span class=\"pl-s\">SwiftUI</span><span class=\"pl-s\">\"</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">Many of these API's are also available as a extension of NSObject which is useful\nwhen SwiftTrace is made available by dynamically loading bundle as in\n(InjectionIII)[<a href=\"https://github.com/johnno1962/InjectionIII\">https://github.com/johnno1962/InjectionIII</a>].</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    SwiftTrace.traceBundle(containing: UIView.class)\n    // becomes\n    UIView.traceBundle()\n\n    SwiftTrace.trace(inInstance: anObject)\n    // becomes\n    anObject.swiftTraceInstance()\"><pre>    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceBundle</span><span class=\"pl-kos\">(</span>containing<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">UIView</span><span class=\"pl-kos\">.</span>class<span class=\"pl-kos\">)</span>\n    // becomes\n    <span class=\"pl-smi\">UIView</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceBundle</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>\n\n    <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">trace</span><span class=\"pl-kos\">(</span>inInstance<span class=\"pl-kos\">:</span> anObject<span class=\"pl-kos\">)</span>\n    // becomes\n    anObject<span class=\"pl-kos\">.</span><span class=\"pl-en\">swiftTraceInstance</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">This is useful when SwiftTrace is made available by dynamically loading a bundle\nsuch as when using (InjectionIII)[<a href=\"https://github.com/johnno1962/InjectionIII\">https://github.com/johnno1962/InjectionIII</a>]. Rather\nthan having to include a CocoaPod, all you need to do is add SwiftTrace.h in the\nInjectionIII application's bundle to your bridging header and dynamically load the bundle.</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"   Bundle(path: &quot;/Applications/InjectionIII.app/Contents/Resources/iOSInjection.bundle&quot;)?.load()\"><pre>   <span class=\"pl-en\">Bundle</span><span class=\"pl-kos\">(</span>path<span class=\"pl-kos\">:</span> <span class=\"pl-s\">\"</span><span class=\"pl-s\">/Applications/InjectionIII.app/Contents/Resources/iOSInjection.bundle</span><span class=\"pl-s\">\"</span><span class=\"pl-kos\">)</span><span class=\"pl-c1\"><span class=\"pl-c1\">?</span></span><span class=\"pl-kos\">.</span><span class=\"pl-en\">load</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span></pre></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Benchmarking</h4><a id=\"user-content-benchmarking\" class=\"anchor\" aria-label=\"Permalink: Benchmarking\" href=\"#benchmarking\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">To benchmark an app or framework, trace it's methods then you can use one of the following:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"   SwiftTrace.sortedElapsedTimes(onlyFirst: 10))\n   SwiftTrace.sortedInvocationCounts(onlyFirst: 10))\"><pre class=\"notranslate\"><code>   SwiftTrace.sortedElapsedTimes(onlyFirst: 10))\n   SwiftTrace.sortedInvocationCounts(onlyFirst: 10))\n</code></pre></div>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Object lifetime tracking</h4><a id=\"user-content-object-lifetime-tracking\" class=\"anchor\" aria-label=\"Permalink: Object lifetime tracking\" href=\"#object-lifetime-tracking\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">You can track the allocations an deallocations of Swift and\nObjective-C classes using the <a href=\"https://github.com/johnno1962/SwiftTrace/blob/main/SwiftTrace/SwiftLifetime.swift\">SwiftTrace.LifetimeTracker</a> class:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"SwiftTrace.swizzleFactory = SwiftTrace.LifetimeTracker.self\nSwiftTrace.traceMainBundleMethods() == 0 {\n    print(&quot;⚠️ Tracing Swift methods can only work if you have -Xlinker -interposable to your project's \\&quot;Other Linker Flags\\&quot;&quot;)\n}\nSwiftTrace.traceMainBundle()\"><pre><span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span>swizzleFactory <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span>LifetimeTracker<span class=\"pl-kos\">.</span>self\n<span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceMainBundleMethods</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">==</span> <span class=\"pl-c1\">0</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-en\">print</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"</span><span class=\"pl-s\">⚠️ Tracing Swift methods can only work if you have -Xlinker -interposable to your project's </span><span class=\"pl-s\">\\\"</span><span class=\"pl-s\">Other Linker Flags</span><span class=\"pl-s\">\\\"</span><span class=\"pl-s\">\"</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">traceMainBundle</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">Each time an object is allocated you will see a <code>.__allocating_init</code> message\nfollowed by the result and the resulting count of live objects allocated\nsince tracing was started. Each time an object is deallocated you will\nsee a <code>cxx_destruct</code> message followed by the number of objects\noustanding for that class.</p>\n<p dir=\"auto\">If you would like to track the lifecycle of Swift structs, create a marker\nclass and add a property to the struct initialised to an instance of it.</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class Marker&lt;What&gt; {}\n\nstruct MyView: SwiftUI.View {\n    var marker = Marker&lt;MyView&gt;()\n}\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-smi\">Marker</span><span class=\"pl-c1\">&lt;</span>What<span class=\"pl-c1\">&gt;</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">struct</span> <span class=\"pl-smi\">MyView</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">SwiftUI</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">View</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">var</span> <span class=\"pl-s1\"><span class=\"pl-c1\">marker</span></span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Marker</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">MyView</span><span class=\"pl-c1\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This idea is based on the <a href=\"https://github.com/krzysztofzablocki/LifetimeTracker\">LifetimeTracker</a>\nproject by <a href=\"https://github.com/krzysztofzablocki\">Krzysztof Zabłocki</a>.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Aspects</h4><a id=\"user-content-aspects\" class=\"anchor\" aria-label=\"Permalink: Aspects\" href=\"#aspects\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">You can add an aspect to a particular method using the method's de-mangled name:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    print(SwiftTrace.addAspect(aClass: TestClass.self,\n                      methodName: &quot;SwiftTwaceApp.TestClass.x() -&gt; ()&quot;,\n                      onEntry: { (_, _) in print(&quot;ONE&quot;) },\n                      onExit: { (_, _) in print(&quot;TWO&quot;) }))\"><pre>    <span class=\"pl-en\">print</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">addAspect</span><span class=\"pl-kos\">(</span>aClass<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">TestClass</span><span class=\"pl-kos\">.</span>self<span class=\"pl-kos\">,</span>\n                      methodName<span class=\"pl-kos\">:</span> <span class=\"pl-s\">\"</span><span class=\"pl-s\">SwiftTwaceApp.TestClass.x() -&gt; ()</span><span class=\"pl-s\">\"</span><span class=\"pl-kos\">,</span>\n                      onEntry<span class=\"pl-kos\">:</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">(</span>_<span class=\"pl-kos\">,</span> _<span class=\"pl-kos\">)</span> <span class=\"pl-k\">in</span> <span class=\"pl-en\">print</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"</span><span class=\"pl-s\">ONE</span><span class=\"pl-s\">\"</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n                      onExit<span class=\"pl-kos\">:</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">(</span>_<span class=\"pl-kos\">,</span> _<span class=\"pl-kos\">)</span> <span class=\"pl-k\">in</span> <span class=\"pl-en\">print</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"</span><span class=\"pl-s\">TWO</span><span class=\"pl-s\">\"</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">This will print \"ONE\" when method \"x\" of TextClass is called and \"TWO when it has exited. The\ntwo arguments are the Swizzle which is an object representing the \"Swizzle\" and the entry or\nexit stack. The full signature for the entry closure is:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"       onEntry: { (swizzle: SwiftTrace.Swizzle, stack: inout SwiftTrace.EntryStack) in\"><pre>       <span class=\"pl-ent\">onEntry:</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">(</span>swizzle<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Swizzle</span><span class=\"pl-kos\">,</span> stack<span class=\"pl-kos\">:</span> <span class=\"pl-k\">inout</span> <span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">EntryStack</span><span class=\"pl-kos\">)</span> in</pre></div>\n<p dir=\"auto\">If you understand how <a href=\"https://github.com/apple/swift/blob/master/docs/ABI/RegisterUsage.md\">registers are allocated</a> to arguments it is possible to poke into the\nstack to modify the incoming arguments and, for the exit aspect closure you can replace\nthe return value and on a good day log (and prevent) an error being thrown.</p>\n<p dir=\"auto\">Replacing an input argument in the closure is relatively simple:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    stack.intArg1 = 99\n    stack.floatArg3 = 77.3\"><pre>    stack<span class=\"pl-kos\">.</span>intArg1 <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">99</span>\n    stack<span class=\"pl-kos\">.</span>floatArg3 <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">77.3</span></pre></div>\n<p dir=\"auto\">Other types of argument a little more involved. They must be cast and String\ntakes up two integer registers.</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    swizzle.rebind(&amp;stack.intArg2).pointee = &quot;Grief&quot;\n    swizzle.rebind(&amp;stack.intArg4).pointee = TestClass()\"><pre>    swizzle<span class=\"pl-kos\">.</span><span class=\"pl-en\">rebind</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">&amp;</span>stack<span class=\"pl-kos\">.</span>intArg2<span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span>pointee <span class=\"pl-c1\">=</span> <span class=\"pl-s\">\"</span><span class=\"pl-s\">Grief</span><span class=\"pl-s\">\"</span>\n    swizzle<span class=\"pl-kos\">.</span><span class=\"pl-en\">rebind</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">&amp;</span>stack<span class=\"pl-kos\">.</span>intArg4<span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span>pointee <span class=\"pl-c1\">=</span> <span class=\"pl-en\">TestClass</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">In an exit aspect closure, setting the return type is easier as it is generic:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    stack.setReturn(value: &quot;Phew&quot;)\"><pre>    stack<span class=\"pl-kos\">.</span><span class=\"pl-en\">setReturn</span><span class=\"pl-kos\">(</span>value<span class=\"pl-kos\">:</span> <span class=\"pl-s\">\"</span><span class=\"pl-s\">Phew</span><span class=\"pl-s\">\"</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">When a function throws you can access NSError objects.</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    print(swizzle.rebind(&amp;stack.thrownError, to: NSError.self).pointee)\"><pre>    <span class=\"pl-en\">print</span><span class=\"pl-kos\">(</span>swizzle<span class=\"pl-kos\">.</span><span class=\"pl-en\">rebind</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">&amp;</span>stack<span class=\"pl-kos\">.</span>thrownError<span class=\"pl-kos\">,</span> to<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">NSError</span><span class=\"pl-kos\">.</span>self<span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span>pointee<span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">It is possible to set <code>stack.thrownError</code> to zero to cancel the throw but you will need to set\nthe return value.</p>\n<p dir=\"auto\">If this seems complicated there is a property <code>swizzle.arguments</code> which can be used\n<code>onEntry</code> which contains the arguments as an <code>Array</code> containing elements of type <code>Any</code>\nwhich can be cast to the expected type. Element 0 is <code>self</code>.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">Invocation interface</h4><a id=\"user-content-invocation-interface\" class=\"anchor\" aria-label=\"Permalink: Invocation interface\" href=\"#invocation-interface\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">Now we have a trampoline infrastructure, it is possible to implement an invocation api for Swift:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    print(&quot;Result: &quot;+SwiftTrace.invoke(target: b,\n        methodName: &quot;SwiftTwaceApp.TestClass.zzz(_: Swift.Int, f: Swift.Double, g: Swift.Float, h: Swift.String, f1: Swift.Double, g1: Swift.Float, h1: Swift.Double, f2: Swift.Double, g2: Swift.Float, h2: Swift.Double, e: Swift.Int, ff: Swift.Int, o: SwiftTwaceApp.TestClass) throws -&gt; Swift.String&quot;,\n        args: 777, 101.0, Float(102.0), &quot;2-2&quot;, 103.0, Float(104.0), 105.0, 106.0, Float(107.0), 108.0, 888, 999, TestClass()))\"><pre>    <span class=\"pl-en\">print</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"</span><span class=\"pl-s\">Result: </span><span class=\"pl-s\">\"</span><span class=\"pl-c1\">+</span>SwiftTrace<span class=\"pl-kos\">.</span><span class=\"pl-en\">invoke</span><span class=\"pl-kos\">(</span>target<span class=\"pl-kos\">:</span> b<span class=\"pl-kos\">,</span>\n        methodName<span class=\"pl-kos\">:</span> <span class=\"pl-s\">\"</span><span class=\"pl-s\">SwiftTwaceApp.TestClass.zzz(_: Swift.Int, f: Swift.Double, g: Swift.Float, h: Swift.String, f1: Swift.Double, g1: Swift.Float, h1: Swift.Double, f2: Swift.Double, g2: Swift.Float, h2: Swift.Double, e: Swift.Int, ff: Swift.Int, o: SwiftTwaceApp.TestClass) throws -&gt; Swift.String</span><span class=\"pl-s\">\"</span><span class=\"pl-kos\">,</span>\n        args<span class=\"pl-kos\">:</span> <span class=\"pl-c1\">777</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">101.0</span><span class=\"pl-kos\">,</span> <span class=\"pl-en\">Float</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">102.0</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">\"</span><span class=\"pl-s\">2-2</span><span class=\"pl-s\">\"</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">103.0</span><span class=\"pl-kos\">,</span> <span class=\"pl-en\">Float</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">104.0</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">105.0</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">106.0</span><span class=\"pl-kos\">,</span> <span class=\"pl-en\">Float</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">107.0</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">108.0</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">888</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">999</span><span class=\"pl-kos\">,</span> <span class=\"pl-en\">TestClass</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">In order to determine the mangled name of a method you can get the full list for a class\nusing this function:</p>\n<div class=\"highlight highlight-source-swift notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    print(SwiftTrace.methodNames(ofClass: TestClass.self))\"><pre>    <span class=\"pl-en\">print</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">SwiftTrace</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">methodNames</span><span class=\"pl-kos\">(</span>ofClass<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">TestClass</span><span class=\"pl-kos\">.</span>self<span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">There are limitations to this abbreviated interface in that it only supports Double, Float,\nString, Int, Object, CGRect, CGSize and CGPoint arguments. For other struct types that\ndo not contain floating point values you can conform them to protocol <code>SwiftTraceArg</code>\nto be able to pass them on the argument list or <code>SwiftTraceFloatArg</code> if they contain\nonly floats. These values and return values must fit into 32 bytes and not contain floats.</p>\n<div class=\"markdown-heading\" dir=\"auto\"><h4 class=\"heading-element\" dir=\"auto\">How it works</h4><a id=\"user-content-how-it-works\" class=\"anchor\" aria-label=\"Permalink: How it works\" href=\"#how-it-works\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></div>\n<p dir=\"auto\">A Swift <code>AnyClass</code> instance has a layout similar to an Objective-C class with some\nadditional data documented in the <code>ClassMetadataSwift</code> in SwiftMeta.swift. After this data\nthere is the vtable of pointers to the class and instance member functions of the class up to\nthe size of the class instance. SwiftTrace replaces these function pointers with a pointer\nto a unique assembly language \"trampoline\" entry point which has destination function and\ndata pointers associated with it. Registers are saved and this function is called passing\nthe data pointer to log the method name. The method name is determined by de-mangling the\nsymbol name associated the function address of the implementing method. The registers are\nthen restored and control is passed to the original function implementing the method.</p>\n<p dir=\"auto\">Please file an issue if you encounter a project that doesn't work while tracing. It should\nbe far more reliable as it uses assembly language trampolines rather than Swizzling like\nXtrace did. Otherwise, the author can be contacted on Twitter <a href=\"https://twitter.com/@Injection4Xcode\" rel=\"nofollow\">@Injection4Xcode</a>.</p>\n<p dir=\"auto\">Thanks to Oliver Letterer for the <a href=\"https://github.com/OliverLetterer/imp_implementationForwardingToSelector\">imp_implementationForwardingToSelector</a> project adapted to set up the\ntrampolines, included under an MIT license.</p>\n<p dir=\"auto\">The repo includes a very slightly modified version of the very handy\n<a href=\"https://github.com/facebook/fishhook\">https://github.com/facebook/fishhook</a>.\nSee the source and header files for their licensing details.</p>\n<p dir=\"auto\">Thanks also  to <a href=\"https://twitter.com/twostraws\" rel=\"nofollow\">@twostraws</a>'\n<a href=\"https://github.com/twostraws/Unwrap\">Unwrap</a> and <a href=\"https://twitter.com/ArtsyOpenSource\" rel=\"nofollow\">@artsy</a>'s\n<a href=\"https://github.com/artsy/eidolon\">eidolon</a> used extensively during testing.</p>\n<p dir=\"auto\">Enjoy!</p>\n<p dir=\"auto\"><math-renderer class=\"js-inline-math\" style=\"display: inline-block\" data-run-id=\"3c385b00742dd6b6e387f002bf02ab40\">$Date: 2022/01/22 $</math-renderer></p>\n</article></div>"
}